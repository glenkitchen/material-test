[{"C:\\dev\\material-table-test\\src\\App.tsx":"1","C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-action.js":"2","C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-body-row.js":"3","C:\\dev\\material-table-test\\src\\index.tsx":"4","C:\\dev\\material-table-test\\src\\material-table\\utils\\data-manager.js":"5","C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-filter-row.js":"6","C:\\dev\\material-table-test\\src\\material-table\\index.js":"7","C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-groupbar.js":"8","C:\\dev\\material-table-test\\src\\material-table\\material-table.js":"9","C:\\dev\\material-table-test\\src\\test-data.ts":"10","C:\\dev\\material-table-test\\src\\material-table\\default-props.js":"11","C:\\dev\\material-table-test\\src\\test-columns.ts":"12","C:\\dev\\material-table-test\\src\\material-table\\components\\index.js":"13","C:\\dev\\material-table-test\\src\\material-table\\utils\\polyfill\\index.js":"14","C:\\dev\\material-table-test\\src\\material-table\\utils\\common-values.js":"15","C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-header.js":"16","C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-stepped-pagination.js":"17","C:\\dev\\material-table-test\\src\\material-table\\prop-types.js":"18","C:\\dev\\material-table-test\\src\\material-table\\utils\\polyfill\\array.find.js":"19","C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-edit-row.js":"20","C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-body.js":"21","C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-toolbar.js":"22","C:\\dev\\material-table-test\\src\\components\\TableSearch.tsx":"23","C:\\dev\\material-table-test\\src\\components\\TableToolbar.tsx":"24","C:\\dev\\material-table-test\\src\\material-table\\utils\\index.js":"25","C:\\dev\\material-table-test\\src\\components\\index.ts":"26","C:\\dev\\material-table-test\\src\\components\\ColumnsButton.tsx":"27","C:\\dev\\material-table-test\\src\\components\\ExportButton.tsx":"28"},{"size":580,"mtime":1606722810017,"results":"29","hashOfConfig":"30"},{"size":2207,"mtime":1602565526655,"results":"31","hashOfConfig":"30"},{"size":17090,"mtime":1602565526655,"results":"32","hashOfConfig":"30"},{"size":500,"mtime":1606395604374,"results":"33","hashOfConfig":"30"},{"size":31910,"mtime":1606571037375,"results":"34","hashOfConfig":"30"},{"size":9895,"mtime":1606554406210,"results":"35","hashOfConfig":"30"},{"size":793,"mtime":1606544489227,"results":"36","hashOfConfig":"30"},{"size":4670,"mtime":1602565526686,"results":"37","hashOfConfig":"30"},{"size":42249,"mtime":1606570858278,"results":"38","hashOfConfig":"30"},{"size":10186,"mtime":1606544183370,"results":"39","hashOfConfig":"30"},{"size":7229,"mtime":1606030024799,"results":"40","hashOfConfig":"30"},{"size":3863,"mtime":1606566634546,"results":"41","hashOfConfig":"30"},{"size":1049,"mtime":1602565526655,"results":"42","hashOfConfig":"30"},{"size":76,"mtime":1602565526686,"results":"43","hashOfConfig":"30"},{"size":839,"mtime":1605979155002,"results":"44","hashOfConfig":"30"},{"size":11667,"mtime":1606563979460,"results":"45","hashOfConfig":"30"},{"size":5293,"mtime":1602565526686,"results":"46","hashOfConfig":"30"},{"size":11530,"mtime":1602565526686,"results":"47","hashOfConfig":"30"},{"size":581,"mtime":1602565526686,"results":"48","hashOfConfig":"30"},{"size":12377,"mtime":1602565526686,"results":"49","hashOfConfig":"30"},{"size":13188,"mtime":1602565526655,"results":"50","hashOfConfig":"30"},{"size":15020,"mtime":1606711826481,"results":"51","hashOfConfig":"30"},{"size":1934,"mtime":1606723957148,"results":"52","hashOfConfig":"30"},{"size":1199,"mtime":1606807599614,"results":"53","hashOfConfig":"30"},{"size":891,"mtime":1602565526686,"results":"54","hashOfConfig":"30"},{"size":295,"mtime":1606713066874,"results":"55","hashOfConfig":"30"},{"size":2170,"mtime":1606799896421,"results":"56","hashOfConfig":"30"},{"size":3134,"mtime":1606807768828,"results":"57","hashOfConfig":"30"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1uytlax",{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70","usedDeprecatedRules":"71"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"85"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"88","messages":"89","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"90"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"93","usedDeprecatedRules":"94"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"99"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"102","messages":"103","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"104","messages":"105","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"106","messages":"107","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"108","messages":"109","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"110","messages":"111","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"112","messages":"113","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"114","messages":"115","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"116","messages":"117","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"118","messages":"119","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"120","messages":"121","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"122","messages":"123","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\dev\\material-table-test\\src\\App.tsx",[],"C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-action.js",[],["124","125"],"C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-body-row.js",[],"C:\\dev\\material-table-test\\src\\index.tsx",[],["126","127"],"C:\\dev\\material-table-test\\src\\material-table\\utils\\data-manager.js",["128","129","130","131","132","133","134","135"],"import formatDate from \"date-fns/format\";\r\nimport { byString } from \"./\";\r\n\r\nexport default class DataManager {\r\n  applyFilters = false;\r\n  applySearch = false;\r\n  applySort = false;\r\n  currentPage = 0;\r\n  detailPanelType = \"multiple\";\r\n  lastDetailPanelRow = undefined;\r\n  lastEditingRow = undefined;\r\n  orderBy = -1;\r\n  orderDirection = \"\";\r\n  pageSize = 5;\r\n  paging = true;\r\n  parentFunc = null;\r\n  searchText = \"\";\r\n  selectedCount = 0;\r\n  treefiedDataLength = 0;\r\n  treeDataMaxLevel = 0;\r\n  groupedDataLength = 0;\r\n  defaultExpanded = false;\r\n  bulkEditOpen = false;\r\n  bulkEditChangedRows = {};\r\n\r\n  data = [];\r\n  columns = [];\r\n\r\n  filteredData = [];\r\n  searchedData = [];\r\n  groupedData = [];\r\n  treefiedData = [];\r\n  sortedData = [];\r\n  pagedData = [];\r\n  renderData = [];\r\n\r\n  filtered = false;\r\n  searched = false;\r\n  grouped = false;\r\n  treefied = false;\r\n  sorted = false;\r\n  paged = false;\r\n\r\n  rootGroupsIndex = {};\r\n\r\n  constructor() {}\r\n\r\n  setData(data) {\r\n    this.selectedCount = 0;\r\n\r\n    this.data = data.map((row, index) => {\r\n      row.tableData = { ...row.tableData, id: index };\r\n      if (row.tableData.checked) {\r\n        this.selectedCount++;\r\n      }\r\n      return row;\r\n    });\r\n\r\n    this.filtered = false;\r\n  }\r\n\r\n  setColumns(columns) {\r\n    const undefinedWidthColumns = columns.filter((c) =>\r\n      c.width === undefined && c.columnDef\r\n        ? c.columnDef.tableData.width === undefined\r\n        : true && !c.hidden\r\n    );\r\n    let usedWidth = [\"0px\"];\r\n\r\n    this.columns = columns.map((columnDef, index) => {\r\n      columnDef.tableData = {\r\n        columnOrder: index,\r\n        filterValue: columnDef.defaultFilter,\r\n        groupOrder: columnDef.defaultGroupOrder,\r\n        groupSort: columnDef.defaultGroupSort || \"asc\",\r\n        width:\r\n          typeof columnDef.width === \"number\"\r\n            ? columnDef.width + \"px\"\r\n            : columnDef.width,\r\n        initialWidth:\r\n          typeof columnDef.width === \"number\"\r\n            ? columnDef.width + \"px\"\r\n            : columnDef.width,\r\n        additionalWidth: 0,\r\n        ...columnDef.tableData,\r\n        id: index,\r\n      };\r\n\r\n      if (columnDef.tableData.width !== undefined) {\r\n        usedWidth.push(columnDef.tableData.width);\r\n      }\r\n\r\n      return columnDef;\r\n    });\r\n\r\n    usedWidth = \"(\" + usedWidth.join(\" + \") + \")\";\r\n    undefinedWidthColumns.forEach((columnDef) => {\r\n      columnDef.tableData.width = columnDef.tableData.initialWidth = `calc((100% - ${usedWidth}) / ${undefinedWidthColumns.length})`;\r\n    });\r\n  }\r\n\r\n  setDefaultExpanded(expanded) {\r\n    this.defaultExpanded = expanded;\r\n  }\r\n\r\n  changeApplySearch(applySearch) {\r\n    this.applySearch = applySearch;\r\n    this.searched = false;\r\n  }\r\n\r\n  changeApplyFilters(applyFilters) {\r\n    this.applyFilters = applyFilters;\r\n    this.filtered = false;\r\n  }\r\n\r\n  changeApplySort(applySort) {\r\n    this.applySort = applySort;\r\n    this.sorted = false;\r\n  }\r\n\r\n  changePaging(paging) {\r\n    this.paging = paging;\r\n    this.paged = false;\r\n  }\r\n\r\n  changeCurrentPage(currentPage) {\r\n    this.currentPage = currentPage;\r\n    this.paged = false;\r\n  }\r\n\r\n  changePageSize(pageSize) {\r\n    this.pageSize = pageSize;\r\n    this.paged = false;\r\n  }\r\n\r\n  changeParentFunc(parentFunc) {\r\n    this.parentFunc = parentFunc;\r\n  }\r\n\r\n  changeFilterValue(columnId, value) {\r\n    this.columns[columnId].tableData.filterValue = value;\r\n    this.filtered = false;\r\n  }\r\n\r\n  changeRowSelected(checked, path) {\r\n    const rowData = this.findDataByPath(this.sortedData, path);\r\n    rowData.tableData.checked = checked;\r\n    this.selectedCount = this.selectedCount + (checked ? 1 : -1);\r\n\r\n    const checkChildRows = (rowData) => {\r\n      if (rowData.tableData.childRows) {\r\n        rowData.tableData.childRows.forEach((childRow) => {\r\n          if (childRow.tableData.checked !== checked) {\r\n            childRow.tableData.checked = checked;\r\n            this.selectedCount = this.selectedCount + (checked ? 1 : -1);\r\n          }\r\n          checkChildRows(childRow);\r\n        });\r\n      }\r\n    };\r\n\r\n    checkChildRows(rowData);\r\n\r\n    this.filtered = false;\r\n  }\r\n\r\n  changeDetailPanelVisibility(path, render) {\r\n    const rowData = this.findDataByPath(this.sortedData, path);\r\n\r\n    if (\r\n      (rowData.tableData.showDetailPanel || \"\").toString() === render.toString()\r\n    ) {\r\n      rowData.tableData.showDetailPanel = undefined;\r\n    } else {\r\n      rowData.tableData.showDetailPanel = render;\r\n    }\r\n\r\n    if (\r\n      this.detailPanelType === \"single\" &&\r\n      this.lastDetailPanelRow &&\r\n      this.lastDetailPanelRow != rowData\r\n    ) {\r\n      this.lastDetailPanelRow.tableData.showDetailPanel = undefined;\r\n    }\r\n\r\n    this.lastDetailPanelRow = rowData;\r\n  }\r\n\r\n  changeGroupExpand(path) {\r\n    const rowData = this.findDataByPath(this.sortedData, path);\r\n    rowData.isExpanded = !rowData.isExpanded;\r\n  }\r\n\r\n  changeSearchText(searchText) {\r\n    this.searchText = searchText;\r\n    this.searched = false;\r\n    this.currentPage = 0;\r\n  }\r\n\r\n  changeRowEditing(rowData, mode) {\r\n    if (rowData) {\r\n      rowData.tableData.editing = mode;\r\n\r\n      if (this.lastEditingRow && this.lastEditingRow != rowData) {\r\n        this.lastEditingRow.tableData.editing = undefined;\r\n      }\r\n\r\n      if (mode) {\r\n        this.lastEditingRow = rowData;\r\n      } else {\r\n        this.lastEditingRow = undefined;\r\n      }\r\n    } else if (this.lastEditingRow) {\r\n      this.lastEditingRow.tableData.editing = undefined;\r\n      this.lastEditingRow = undefined;\r\n    }\r\n  }\r\n\r\n  changeBulkEditOpen(bulkEditOpen) {\r\n    this.bulkEditOpen = bulkEditOpen;\r\n  }\r\n\r\n  changeAllSelected(checked) {\r\n    let selectedCount = 0;\r\n    if (this.isDataType(\"group\")) {\r\n      const setCheck = (data) => {\r\n        data.forEach((element) => {\r\n          if (element.groups.length > 0) {\r\n            setCheck(element.groups);\r\n          } else {\r\n            element.data.forEach((d) => {\r\n              d.tableData.checked = d.tableData.disabled ? false : checked;\r\n              selectedCount++;\r\n            });\r\n          }\r\n        });\r\n      };\r\n\r\n      setCheck(this.groupedData);\r\n    } else {\r\n      this.searchedData.map((row) => {\r\n        row.tableData.checked = row.tableData.disabled ? false : checked;\r\n        return row;\r\n      });\r\n      selectedCount = this.searchedData.length;\r\n    }\r\n\r\n    this.selectedCount = checked ? selectedCount : 0;\r\n  }\r\n\r\n  changeOrder(orderBy, orderDirection) {\r\n    this.orderBy = orderBy;\r\n    this.orderDirection = orderDirection;\r\n    this.currentPage = 0;\r\n\r\n    this.sorted = false;\r\n  }\r\n\r\n  changeGroupOrder(columnId) {\r\n    const column = this.columns.find((c) => c.tableData.id === columnId);\r\n\r\n    if (column.tableData.groupSort === \"asc\") {\r\n      column.tableData.groupSort = \"desc\";\r\n    } else {\r\n      column.tableData.groupSort = \"asc\";\r\n    }\r\n\r\n    this.sorted = false;\r\n  }\r\n\r\n  changeColumnHidden(column, hidden) {\r\n    column.hidden = hidden;\r\n    column.hiddenByColumnsButton = hidden;\r\n  }\r\n\r\n  changeTreeExpand(path) {\r\n    const rowData = this.findDataByPath(this.sortedData, path);\r\n    rowData.tableData.isTreeExpanded = !rowData.tableData.isTreeExpanded;\r\n  }\r\n\r\n  changeDetailPanelType(type) {\r\n    this.detailPanelType = type;\r\n  }\r\n\r\n  changeByDrag(result) {\r\n    let start = 0;\r\n    let groups = this.columns\r\n      .filter((col) => col.tableData.groupOrder > -1)\r\n      .sort(\r\n        (col1, col2) => col1.tableData.groupOrder - col2.tableData.groupOrder\r\n      );\r\n    if (\r\n      result.destination.droppableId === \"groups\" &&\r\n      result.source.droppableId === \"groups\"\r\n    ) {\r\n      start = Math.min(result.destination.index, result.source.index);\r\n      const end = Math.max(result.destination.index, result.source.index);\r\n      groups = groups.slice(start, end + 1);\r\n      if (result.destination.index < result.source.index) {\r\n        // Take last and add as first\r\n        const last = groups.pop();\r\n        groups.unshift(last);\r\n      } else {\r\n        // Take first and add as last\r\n        const last = groups.shift();\r\n        groups.push(last);\r\n      }\r\n    } else if (\r\n      result.destination.droppableId === \"groups\" &&\r\n      result.source.droppableId === \"headers\"\r\n    ) {\r\n      const newGroup = this.columns.find(\r\n        (c) => c.tableData.id == result.draggableId\r\n      );\r\n      if (newGroup.grouping === false || !newGroup.field) {\r\n        return;\r\n      }\r\n      groups.splice(result.destination.index, 0, newGroup);\r\n    } else if (\r\n      result.destination.droppableId === \"headers\" &&\r\n      result.source.droppableId === \"groups\"\r\n    ) {\r\n      const removeGroup = this.columns.find(\r\n        (c) => c.tableData.id == result.draggableId\r\n      );\r\n      removeGroup.tableData.groupOrder = undefined;\r\n      groups.splice(result.source.index, 1);\r\n    } else if (\r\n      result.destination.droppableId === \"headers\" &&\r\n      result.source.droppableId === \"headers\"\r\n    ) {\r\n      const sourceIndex = result.source.index;\r\n      const destinationIndex = result.destination.index;\r\n\r\n      if (sourceIndex === destinationIndex) {\r\n        return;\r\n      }\r\n\r\n      const sourceColumnOrder = this.columns[destinationIndex].tableData\r\n        .columnOrder;\r\n      const destinationColumnOrder = this.columns[sourceIndex].tableData\r\n        .columnOrder;\r\n\r\n      this.columns[sourceIndex].tableData.columnOrder = sourceColumnOrder;\r\n      this.columns[\r\n        destinationIndex\r\n      ].tableData.columnOrder = destinationColumnOrder;\r\n\r\n      // start = Math.min(result.destination.index, result.source.index);\r\n      // const end = Math.max(result.destination.index, result.source.index);\r\n      // // get the effective start and end considering hidden columns\r\n      // const sorted = this.columns\r\n      //   .sort((a, b) => a.tableData.columnOrder - b.tableData.columnOrder)\r\n      //   .filter((column) => column.tableData.groupOrder === undefined);\r\n      // let numHiddenBeforeStart = 0;\r\n      // let numVisibleBeforeStart = 0;\r\n      // for (\r\n      //   let i = 0;\r\n      //   i < sorted.length && numVisibleBeforeStart <= start;\r\n      //   i++\r\n      // ) {\r\n      //   if (sorted[i].hidden) {\r\n      //     numHiddenBeforeStart++;\r\n      //   } else {\r\n      //     numVisibleBeforeStart++;\r\n      //   }\r\n      // }\r\n      // const effectiveStart = start + numHiddenBeforeStart;\r\n      // let effectiveEnd = effectiveStart;\r\n      // for (\r\n      //   let numVisibleInRange = 0;\r\n      //   numVisibleInRange < end - start && effectiveEnd < sorted.length;\r\n      //   effectiveEnd++\r\n      // ) {\r\n      //   if (!sorted[effectiveEnd].hidden) {\r\n      //     numVisibleInRange++;\r\n      //   }\r\n      // }\r\n      // const colsToMov = sorted.slice(effectiveStart, effectiveEnd + 1);\r\n      // if (result.destination.index < result.source.index) {\r\n      //   // Take last and add as first\r\n      //   const last = colsToMov.pop();\r\n      //   colsToMov.unshift(last);\r\n      // } else {\r\n      //   // Take first and add as last\r\n      //   const last = colsToMov.shift();\r\n      //   colsToMov.push(last);\r\n      // }\r\n      // for (let i = 0; i < colsToMov.length; i++) {\r\n      //   colsToMov[i].tableData.columnOrder = effectiveStart + i;\r\n      // }\r\n\r\n      return;\r\n    } else {\r\n      return;\r\n    }\r\n    for (let i = 0; i < groups.length; i++) {\r\n      groups[i].tableData.groupOrder = start + i;\r\n    }\r\n    this.sorted = this.grouped = false;\r\n  }\r\n\r\n  startCellEditable = (rowData, columnDef) => {\r\n    rowData.tableData.editCellList = [\r\n      ...(rowData.tableData.editCellList || []),\r\n      columnDef,\r\n    ];\r\n  };\r\n\r\n  finishCellEditable = (rowData, columnDef) => {\r\n    if (rowData.tableData.editCellList) {\r\n      var index = rowData.tableData.editCellList.findIndex(\r\n        (c) => c.tableData.id === columnDef.tableData.id\r\n      );\r\n      if (index !== -1) {\r\n        rowData.tableData.editCellList.splice(index, 1);\r\n      }\r\n    }\r\n  };\r\n\r\n  clearBulkEditChangedRows = () => {\r\n    this.bulkEditChangedRows = {};\r\n  };\r\n\r\n  onBulkEditRowChanged = (oldData, newData) => {\r\n    this.bulkEditChangedRows[oldData.tableData.id] = {\r\n      oldData,\r\n      newData,\r\n    };\r\n  };\r\n\r\n  onColumnResized(id, additionalWidth) {\r\n    const column = this.columns.find((c) => c.tableData.id === id);\r\n    if (!column) return;\r\n\r\n    const nextColumn = this.columns.find((c) => c.tableData.id === id + 1);\r\n    if (!nextColumn) return;\r\n\r\n    // console.log(\"S i: \" + column.tableData.initialWidth);\r\n    // console.log(\"S a: \" + column.tableData.additionalWidth);\r\n    // console.log(\"S w: \" + column.tableData.width);\r\n\r\n    column.tableData.additionalWidth = additionalWidth;\r\n    column.tableData.width = `calc(${column.tableData.initialWidth} + ${column.tableData.additionalWidth}px)`;\r\n\r\n    // nextColumn.tableData.additionalWidth = -1 * additionalWidth;\r\n    // nextColumn.tableData.width = `calc(${nextColumn.tableData.initialWidth} + ${nextColumn.tableData.additionalWidth}px)`;\r\n\r\n    // console.log(\"F i: \" + column.tableData.initialWidth);\r\n    // console.log(\"F a: \" + column.tableData.additionalWidth);\r\n    // console.log(\"F w: \" + column.tableData.width);\r\n  }\r\n\r\n  expandTreeForNodes = (data) => {\r\n    data.forEach((row) => {\r\n      let currentRow = row;\r\n      while (this.parentFunc(currentRow, this.data)) {\r\n        let parent = this.parentFunc(currentRow, this.data);\r\n        if (parent) {\r\n          parent.tableData.isTreeExpanded = true;\r\n        }\r\n        currentRow = parent;\r\n      }\r\n    });\r\n  };\r\n\r\n  findDataByPath = (renderData, path) => {\r\n    if (this.isDataType(\"tree\")) {\r\n      const node = path.reduce(\r\n        (result, current) => {\r\n          return (\r\n            result &&\r\n            result.tableData &&\r\n            result.tableData.childRows &&\r\n            result.tableData.childRows[current]\r\n          );\r\n        },\r\n        { tableData: { childRows: renderData } }\r\n      );\r\n\r\n      return node;\r\n    } else {\r\n      const data = { groups: renderData };\r\n\r\n      const node = path.reduce((result, current) => {\r\n        if (result.groups.length > 0) {\r\n          return result.groups[current];\r\n        } else if (result.data) {\r\n          return result.data[current];\r\n        } else {\r\n          return undefined;\r\n        }\r\n      }, data);\r\n      return node;\r\n    }\r\n  };\r\n\r\n  findGroupByGroupPath(renderData, path) {\r\n    const data = { groups: renderData, groupsIndex: this.rootGroupsIndex };\r\n\r\n    const node = path.reduce((result, current) => {\r\n      if (!result) {\r\n        return undefined;\r\n      }\r\n\r\n      if (result.groupsIndex[current] !== undefined) {\r\n        return result.groups[result.groupsIndex[current]];\r\n      }\r\n      return undefined;\r\n      // const group = result.groups.find(a => a.value === current);\r\n      // return group;\r\n    }, data);\r\n    return node;\r\n  }\r\n\r\n  getFieldValue = (rowData, columnDef, lookup = true) => {\r\n    let value =\r\n      typeof rowData[columnDef.field] !== \"undefined\"\r\n        ? rowData[columnDef.field]\r\n        : byString(rowData, columnDef.field);\r\n    if (columnDef.lookup && lookup) {\r\n      value = columnDef.lookup[value];\r\n    }\r\n\r\n    return value;\r\n  };\r\n\r\n  isDataType(type) {\r\n    let dataType = \"normal\";\r\n\r\n    if (this.parentFunc) {\r\n      dataType = \"tree\";\r\n    } else if (this.columns.find((a) => a.tableData.groupOrder > -1)) {\r\n      dataType = \"group\";\r\n    }\r\n\r\n    return type === dataType;\r\n  }\r\n\r\n  sort(a, b, type) {\r\n    if (type === \"numeric\") {\r\n      return a - b;\r\n    } else {\r\n      if (a !== b) {\r\n        // to find nulls\r\n        if (!a) return -1;\r\n        if (!b) return 1;\r\n      }\r\n      return a < b ? -1 : a > b ? 1 : 0;\r\n    }\r\n  }\r\n\r\n  sortList(list) {\r\n    const columnDef = this.columns.find((_) => _.tableData.id === this.orderBy);\r\n    let result = list;\r\n\r\n    if (columnDef.customSort) {\r\n      if (this.orderDirection === \"desc\") {\r\n        result = list.sort((a, b) => columnDef.customSort(b, a, \"row\", \"desc\"));\r\n      } else {\r\n        result = list.sort((a, b) => columnDef.customSort(a, b, \"row\"));\r\n      }\r\n    } else {\r\n      result = list.sort(\r\n        this.orderDirection === \"desc\"\r\n          ? (a, b) =>\r\n              this.sort(\r\n                this.getFieldValue(b, columnDef),\r\n                this.getFieldValue(a, columnDef),\r\n                columnDef.type\r\n              )\r\n          : (a, b) =>\r\n              this.sort(\r\n                this.getFieldValue(a, columnDef),\r\n                this.getFieldValue(b, columnDef),\r\n                columnDef.type\r\n              )\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  getRenderState = () => {\r\n    if (this.filtered === false) {\r\n      this.filterData();\r\n    }\r\n\r\n    if (this.searched === false) {\r\n      this.searchData();\r\n    }\r\n\r\n    if (this.grouped === false && this.isDataType(\"group\")) {\r\n      this.groupData();\r\n    }\r\n\r\n    if (this.treefied === false && this.isDataType(\"tree\")) {\r\n      this.treefyData();\r\n    }\r\n\r\n    if (this.sorted === false) {\r\n      this.sortData();\r\n    }\r\n\r\n    if (this.paged === false) {\r\n      this.pageData();\r\n    }\r\n\r\n    return {\r\n      columns: this.columns,\r\n      currentPage: this.currentPage,\r\n      data: this.sortedData,\r\n      lastEditingRow: this.lastEditingRow,\r\n      orderBy: this.orderBy,\r\n      orderDirection: this.orderDirection,\r\n      originalData: this.data,\r\n      pageSize: this.pageSize,\r\n      renderData: this.pagedData,\r\n      searchText: this.searchText,\r\n      selectedCount: this.selectedCount,\r\n      treefiedDataLength: this.treefiedDataLength,\r\n      treeDataMaxLevel: this.treeDataMaxLevel,\r\n      groupedDataLength: this.groupedDataLength,\r\n    };\r\n  };\r\n\r\n  // =====================================================================================================\r\n  // DATA MANUPULATIONS\r\n  // =====================================================================================================\r\n\r\n  filterData = () => {\r\n    this.searched = this.grouped = this.treefied = this.sorted = this.paged = false;\r\n\r\n    this.filteredData = [...this.data];\r\n\r\n    if (this.applyFilters) {\r\n      this.columns\r\n        .filter((columnDef) => columnDef.tableData.filterValue)\r\n        .forEach((columnDef) => {\r\n          const { lookup, type, tableData } = columnDef;\r\n          if (columnDef.customFilterAndSearch) {\r\n            this.filteredData = this.filteredData.filter(\r\n              (row) =>\r\n                !!columnDef.customFilterAndSearch(\r\n                  tableData.filterValue,\r\n                  row,\r\n                  columnDef\r\n                )\r\n            );\r\n          } else {\r\n            if (lookup) {\r\n              this.filteredData = this.filteredData.filter((row) => {\r\n                const value = this.getFieldValue(row, columnDef, false);\r\n                return (\r\n                  !tableData.filterValue ||\r\n                  tableData.filterValue.length === 0 ||\r\n                  tableData.filterValue.indexOf(\r\n                    value !== undefined && value !== null && value.toString()\r\n                  ) > -1\r\n                );\r\n              });\r\n            } else if (type === \"numeric\") {\r\n              this.filteredData = this.filteredData.filter((row) => {\r\n                const value = this.getFieldValue(row, columnDef);\r\n                return value + \"\" === tableData.filterValue;\r\n              });\r\n            } else if (type === \"boolean\" && tableData.filterValue) {\r\n              this.filteredData = this.filteredData.filter((row) => {\r\n                const value = this.getFieldValue(row, columnDef);\r\n                return (\r\n                  (value && tableData.filterValue === \"checked\") ||\r\n                  (!value && tableData.filterValue === \"unchecked\")\r\n                );\r\n              });\r\n            } else if ([\"date\", \"datetime\"].includes(type)) {\r\n              this.filteredData = this.filteredData.filter((row) => {\r\n                const value = this.getFieldValue(row, columnDef);\r\n\r\n                const currentDate = value ? new Date(value) : null;\r\n\r\n                if (currentDate && currentDate.toString() !== \"Invalid Date\") {\r\n                  const selectedDate = tableData.filterValue;\r\n                  let currentDateToCompare = \"\";\r\n                  let selectedDateToCompare = \"\";\r\n\r\n                  if (type === \"date\") {\r\n                    currentDateToCompare = formatDate(\r\n                      currentDate,\r\n                      \"MM/dd/yyyy\"\r\n                    );\r\n                    selectedDateToCompare = formatDate(\r\n                      selectedDate,\r\n                      \"MM/dd/yyyy\"\r\n                    );\r\n                  } else if (type === \"datetime\") {\r\n                    currentDateToCompare = formatDate(\r\n                      currentDate,\r\n                      \"MM/dd/yyyy - HH:mm\"\r\n                    );\r\n                    selectedDateToCompare = formatDate(\r\n                      selectedDate,\r\n                      \"MM/dd/yyyy - HH:mm\"\r\n                    );\r\n                  }\r\n\r\n                  return currentDateToCompare === selectedDateToCompare;\r\n                }\r\n\r\n                return true;\r\n              });\r\n            } else if (type === \"time\") {\r\n              this.filteredData = this.filteredData.filter((row) => {\r\n                const value = this.getFieldValue(row, columnDef);\r\n                const currentHour = value || null;\r\n\r\n                if (currentHour) {\r\n                  const selectedHour = tableData.filterValue;\r\n                  const currentHourToCompare = formatDate(\r\n                    selectedHour,\r\n                    \"HH:mm\"\r\n                  );\r\n\r\n                  return currentHour === currentHourToCompare;\r\n                }\r\n\r\n                return true;\r\n              });\r\n            } else {\r\n              this.filteredData = this.filteredData.filter((row) => {\r\n                const value = this.getFieldValue(row, columnDef);\r\n                return (\r\n                  value &&\r\n                  value\r\n                    .toString()\r\n                    .toUpperCase()\r\n                    .includes(tableData.filterValue.toUpperCase())\r\n                );\r\n              });\r\n            }\r\n          }\r\n        });\r\n    }\r\n\r\n    this.filtered = true;\r\n  };\r\n\r\n  searchData = () => {\r\n    this.grouped = this.treefied = this.sorted = this.paged = false;\r\n\r\n    this.searchedData = [...this.filteredData];\r\n\r\n    if (this.searchText && this.applySearch) {\r\n      const trimmedSearchText = this.searchText.trim();\r\n      this.searchedData = this.searchedData.filter((row) => {\r\n        return this.columns\r\n          .filter((columnDef) => {\r\n            return columnDef.searchable === undefined\r\n              ? !columnDef.hidden\r\n              : columnDef.searchable;\r\n          })\r\n          .some((columnDef) => {\r\n            if (columnDef.customFilterAndSearch) {\r\n              return !!columnDef.customFilterAndSearch(\r\n                trimmedSearchText,\r\n                row,\r\n                columnDef\r\n              );\r\n            } else if (columnDef.field) {\r\n              const value = this.getFieldValue(row, columnDef);\r\n              if (value) {\r\n                return value\r\n                  .toString()\r\n                  .toUpperCase()\r\n                  .includes(trimmedSearchText.toUpperCase());\r\n              }\r\n            }\r\n          });\r\n      });\r\n    }\r\n    this.searched = true;\r\n  };\r\n\r\n  groupData() {\r\n    this.sorted = this.paged = false;\r\n    this.groupedDataLength = 0;\r\n\r\n    const tmpData = [...this.searchedData];\r\n\r\n    const groups = this.columns\r\n      .filter((col) => col.tableData.groupOrder > -1)\r\n      .sort(\r\n        (col1, col2) => col1.tableData.groupOrder - col2.tableData.groupOrder\r\n      );\r\n\r\n    const subData = tmpData.reduce(\r\n      (result, currentRow) => {\r\n        let object = result;\r\n        object = groups.reduce((o, colDef) => {\r\n          const value =\r\n            currentRow[colDef.field] || byString(currentRow, colDef.field);\r\n\r\n          let group;\r\n          if (o.groupsIndex[value] !== undefined) {\r\n            group = o.groups[o.groupsIndex[value]];\r\n          }\r\n\r\n          if (!group) {\r\n            const path = [...(o.path || []), value];\r\n            let oldGroup = this.findGroupByGroupPath(\r\n              this.groupedData,\r\n              path\r\n            ) || {\r\n              isExpanded:\r\n                typeof this.defaultExpanded === \"boolean\"\r\n                  ? this.defaultExpanded\r\n                  : false,\r\n            };\r\n\r\n            group = {\r\n              value,\r\n              groups: [],\r\n              groupsIndex: {},\r\n              data: [],\r\n              isExpanded: oldGroup.isExpanded,\r\n              path: path,\r\n            };\r\n            o.groups.push(group);\r\n            o.groupsIndex[value] = o.groups.length - 1;\r\n          }\r\n          return group;\r\n        }, object);\r\n\r\n        object.data.push(currentRow);\r\n        this.groupedDataLength++;\r\n\r\n        return result;\r\n      },\r\n      { groups: [], groupsIndex: {} }\r\n    );\r\n\r\n    this.groupedData = subData.groups;\r\n    this.grouped = true;\r\n    this.rootGroupsIndex = subData.groupsIndex;\r\n  }\r\n\r\n  treefyData() {\r\n    this.sorted = this.paged = false;\r\n    this.data.forEach((a) => (a.tableData.childRows = null));\r\n    this.treefiedData = [];\r\n    this.treefiedDataLength = 0;\r\n    this.treeDataMaxLevel = 0;\r\n\r\n    // if filter or search is enabled, collapse the tree\r\n    if (\r\n      this.searchText ||\r\n      this.columns.some((columnDef) => columnDef.tableData.filterValue)\r\n    ) {\r\n      this.data.forEach((row) => {\r\n        row.tableData.isTreeExpanded = false;\r\n      });\r\n\r\n      // expand the tree for all nodes present after filtering and searching\r\n      this.expandTreeForNodes(this.searchedData);\r\n    }\r\n\r\n    const addRow = (rowData) => {\r\n      rowData.tableData.markedForTreeRemove = false;\r\n      let parent = this.parentFunc(rowData, this.data);\r\n      if (parent) {\r\n        parent.tableData.childRows = parent.tableData.childRows || [];\r\n        if (!parent.tableData.childRows.includes(rowData)) {\r\n          parent.tableData.childRows.push(rowData);\r\n          this.treefiedDataLength++;\r\n        }\r\n\r\n        addRow(parent);\r\n\r\n        rowData.tableData.path = [\r\n          ...parent.tableData.path,\r\n          parent.tableData.childRows.length - 1,\r\n        ];\r\n        this.treeDataMaxLevel = Math.max(\r\n          this.treeDataMaxLevel,\r\n          rowData.tableData.path.length\r\n        );\r\n      } else {\r\n        if (!this.treefiedData.includes(rowData)) {\r\n          this.treefiedData.push(rowData);\r\n          this.treefiedDataLength++;\r\n          rowData.tableData.path = [this.treefiedData.length - 1];\r\n        }\r\n      }\r\n    };\r\n\r\n    // Add all rows initially\r\n    this.data.forEach((rowData) => {\r\n      addRow(rowData);\r\n    });\r\n    const markForTreeRemove = (rowData) => {\r\n      let pointer = this.treefiedData;\r\n      rowData.tableData.path.forEach((pathPart) => {\r\n        if (pointer.tableData && pointer.tableData.childRows) {\r\n          pointer = pointer.tableData.childRows;\r\n        }\r\n        pointer = pointer[pathPart];\r\n      });\r\n      pointer.tableData.markedForTreeRemove = true;\r\n    };\r\n\r\n    const traverseChildrenAndUnmark = (rowData) => {\r\n      if (rowData.tableData.childRows) {\r\n        rowData.tableData.childRows.forEach((row) => {\r\n          traverseChildrenAndUnmark(row);\r\n        });\r\n      }\r\n      rowData.tableData.markedForTreeRemove = false;\r\n    };\r\n\r\n    // for all data rows, restore initial expand if no search term is available and remove items that shouldn't be there\r\n    this.data.forEach((rowData) => {\r\n      if (\r\n        !this.searchText &&\r\n        !this.columns.some((columnDef) => columnDef.tableData.filterValue)\r\n      ) {\r\n        if (rowData.tableData.isTreeExpanded === undefined) {\r\n          var isExpanded =\r\n            typeof this.defaultExpanded === \"boolean\"\r\n              ? this.defaultExpanded\r\n              : this.defaultExpanded(rowData);\r\n          rowData.tableData.isTreeExpanded = isExpanded;\r\n        }\r\n      }\r\n      const hasSearchMatchedChildren = rowData.tableData.isTreeExpanded;\r\n\r\n      if (!hasSearchMatchedChildren && this.searchedData.indexOf(rowData) < 0) {\r\n        markForTreeRemove(rowData);\r\n      }\r\n    });\r\n\r\n    // preserve all children of nodes that are matched by search or filters\r\n    this.data.forEach((rowData) => {\r\n      if (this.searchedData.indexOf(rowData) > -1) {\r\n        traverseChildrenAndUnmark(rowData);\r\n      }\r\n    });\r\n\r\n    const traverseTreeAndDeleteMarked = (rowDataArray) => {\r\n      for (var i = rowDataArray.length - 1; i >= 0; i--) {\r\n        const item = rowDataArray[i];\r\n        if (item.tableData.childRows) {\r\n          traverseTreeAndDeleteMarked(item.tableData.childRows);\r\n        }\r\n        if (item.tableData.markedForTreeRemove) rowDataArray.splice(i, 1);\r\n      }\r\n    };\r\n\r\n    traverseTreeAndDeleteMarked(this.treefiedData);\r\n    this.treefied = true;\r\n  }\r\n\r\n  sortData() {\r\n    this.paged = false;\r\n\r\n    if (this.isDataType(\"group\")) {\r\n      this.sortedData = [...this.groupedData];\r\n\r\n      const groups = this.columns\r\n        .filter((col) => col.tableData.groupOrder > -1)\r\n        .sort(\r\n          (col1, col2) => col1.tableData.groupOrder - col2.tableData.groupOrder\r\n        );\r\n\r\n      const sortGroups = (list, columnDef) => {\r\n        if (columnDef.customSort) {\r\n          return list.sort(\r\n            columnDef.tableData.groupSort === \"desc\"\r\n              ? (a, b) => columnDef.customSort(b.value, a.value, \"group\")\r\n              : (a, b) => columnDef.customSort(a.value, b.value, \"group\")\r\n          );\r\n        } else {\r\n          return list.sort(\r\n            columnDef.tableData.groupSort === \"desc\"\r\n              ? (a, b) => this.sort(b.value, a.value, columnDef.type)\r\n              : (a, b) => this.sort(a.value, b.value, columnDef.type)\r\n          );\r\n        }\r\n      };\r\n\r\n      this.sortedData = sortGroups(this.sortedData, groups[0]);\r\n\r\n      const sortGroupData = (list, level) => {\r\n        list.forEach((element) => {\r\n          if (element.groups.length > 0) {\r\n            const column = groups[level];\r\n            element.groups = sortGroups(element.groups, column);\r\n            sortGroupData(element.groups, level + 1);\r\n          } else {\r\n            if (this.orderBy >= 0 && this.orderDirection) {\r\n              element.data = this.sortList(element.data);\r\n            }\r\n          }\r\n        });\r\n      };\r\n\r\n      sortGroupData(this.sortedData, 1);\r\n    } else if (this.isDataType(\"tree\")) {\r\n      this.sortedData = [...this.treefiedData];\r\n      if (this.orderBy != -1) {\r\n        this.sortedData = this.sortList(this.sortedData);\r\n\r\n        const sortTree = (list) => {\r\n          list.forEach((item) => {\r\n            if (item.tableData.childRows) {\r\n              item.tableData.childRows = this.sortList(\r\n                item.tableData.childRows\r\n              );\r\n              sortTree(item.tableData.childRows);\r\n            }\r\n          });\r\n        };\r\n\r\n        sortTree(this.sortedData);\r\n      }\r\n    } else if (this.isDataType(\"normal\")) {\r\n      this.sortedData = [...this.searchedData];\r\n      if (this.orderBy != -1 && this.applySort) {\r\n        this.sortedData = this.sortList(this.sortedData);\r\n      }\r\n    }\r\n\r\n    this.sorted = true;\r\n  }\r\n\r\n  pageData() {\r\n    this.pagedData = [...this.sortedData];\r\n\r\n    if (this.paging) {\r\n      const startIndex = this.currentPage * this.pageSize;\r\n      const endIndex = startIndex + this.pageSize;\r\n\r\n      this.pagedData = this.pagedData.slice(startIndex, endIndex);\r\n    }\r\n\r\n    this.paged = true;\r\n  }\r\n}\r\n\r\n// const printColumn = (col) => ({\r\n//   ...col,\r\n//   tableData: {\r\n//     id: col.tableData.id,\r\n//     columnOrder: col.tableData.columnOrder,\r\n//   },\r\n// });\r\n",["136","137"],"C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-filter-row.js",[],["138","139"],"C:\\dev\\material-table-test\\src\\material-table\\index.js",[],"C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-groupbar.js",[],"C:\\dev\\material-table-test\\src\\material-table\\material-table.js",[],"C:\\dev\\material-table-test\\src\\test-data.ts",[],"C:\\dev\\material-table-test\\src\\material-table\\default-props.js",[],["140","141"],"C:\\dev\\material-table-test\\src\\test-columns.ts",[],"C:\\dev\\material-table-test\\src\\material-table\\components\\index.js",[],["142","143"],"C:\\dev\\material-table-test\\src\\material-table\\utils\\polyfill\\index.js",["144"],"\"use strict\";\r\nif (!Array.prototype.find) {\r\n  require(\"./array.find\");\r\n}\r\n",["145","146"],"C:\\dev\\material-table-test\\src\\material-table\\utils\\common-values.js",[],"C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-header.js",[],["147","148"],"C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-stepped-pagination.js",[],"C:\\dev\\material-table-test\\src\\material-table\\prop-types.js",[],"C:\\dev\\material-table-test\\src\\material-table\\utils\\polyfill\\array.find.js",["149"],"C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-edit-row.js",["150","151","152"],"C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-body.js",[],"C:\\dev\\material-table-test\\src\\material-table\\components\\m-table-toolbar.js",[],"C:\\dev\\material-table-test\\src\\components\\TableSearch.tsx",[],"C:\\dev\\material-table-test\\src\\components\\TableToolbar.tsx",[],"C:\\dev\\material-table-test\\src\\material-table\\utils\\index.js",[],"C:\\dev\\material-table-test\\src\\components\\index.ts",[],"C:\\dev\\material-table-test\\src\\components\\ColumnsButton.tsx",[],"C:\\dev\\material-table-test\\src\\components\\ExportButton.tsx",[],{"ruleId":"153","replacedBy":"154"},{"ruleId":"155","replacedBy":"156"},{"ruleId":"153","replacedBy":"157"},{"ruleId":"155","replacedBy":"158"},{"ruleId":"159","severity":1,"message":"160","line":46,"column":3,"nodeType":"161","messageId":"162","endLine":46,"endColumn":19},{"ruleId":"163","severity":1,"message":"164","line":181,"column":31,"nodeType":"165","messageId":"166","endLine":181,"endColumn":33},{"ruleId":"163","severity":1,"message":"164","line":204,"column":54,"nodeType":"165","messageId":"166","endLine":204,"endColumn":56},{"ruleId":"163","severity":1,"message":"167","line":313,"column":31,"nodeType":"165","messageId":"166","endLine":313,"endColumn":33},{"ruleId":"163","severity":1,"message":"167","line":324,"column":31,"nodeType":"165","messageId":"166","endLine":324,"endColumn":33},{"ruleId":"168","severity":1,"message":"169","line":761,"column":29,"nodeType":"170","messageId":"171","endLine":761,"endColumn":31},{"ruleId":"163","severity":1,"message":"164","line":1008,"column":24,"nodeType":"165","messageId":"166","endLine":1008,"endColumn":26},{"ruleId":"163","severity":1,"message":"164","line":1026,"column":24,"nodeType":"165","messageId":"166","endLine":1026,"endColumn":26},{"ruleId":"153","replacedBy":"172"},{"ruleId":"155","replacedBy":"173"},{"ruleId":"153","replacedBy":"174"},{"ruleId":"155","replacedBy":"175"},{"ruleId":"153","replacedBy":"176"},{"ruleId":"155","replacedBy":"177"},{"ruleId":"153","replacedBy":"157"},{"ruleId":"155","replacedBy":"158"},{"ruleId":"178","severity":1,"message":"179","line":1,"column":1,"nodeType":"180","messageId":"181","endLine":1,"endColumn":14,"fix":"182"},{"ruleId":"153","replacedBy":"183"},{"ruleId":"155","replacedBy":"184"},{"ruleId":"153","replacedBy":"185"},{"ruleId":"155","replacedBy":"186"},{"ruleId":"187","severity":1,"message":"188","line":1,"column":1,"nodeType":"189","messageId":"166","endLine":22,"endColumn":3},{"ruleId":"190","severity":1,"message":"191","line":108,"column":13,"nodeType":"192","messageId":"193","endLine":118,"endColumn":14},{"ruleId":"168","severity":1,"message":"194","line":182,"column":55,"nodeType":"170","messageId":"171","endLine":182,"endColumn":57},{"ruleId":"190","severity":1,"message":"191","line":185,"column":9,"nodeType":"192","messageId":"193","endLine":192,"endColumn":10},"no-native-reassign",["195"],"no-negated-in-lhs",["196"],["195"],["196"],"no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","array-callback-return","Array.prototype.some() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd",["195"],["196"],["195"],["196"],["195"],["196"],"strict","'use strict' is unnecessary inside of modules.","ExpressionStatement","module",{"range":"197","text":"198"},["195"],["196"],["195"],["196"],"no-extend-native","Array prototype is read only, properties should not be added.","CallExpression","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","Array.prototype.every() expects a value to be returned at the end of arrow function.","no-global-assign","no-unsafe-negation",[0,13],""]